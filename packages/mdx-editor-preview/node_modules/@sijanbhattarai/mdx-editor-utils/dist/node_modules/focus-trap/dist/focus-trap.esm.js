import { tabbable as ae, focusable as re, isTabbable as k, getTabIndex as R, isFocusable as x } from "../../tabbable/dist/index.esm.js";
/*!
* focus-trap 7.6.5
* @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE
*/
function G(n, t) {
  (t == null || t > n.length) && (t = n.length);
  for (var o = 0, u = Array(t); o < t; o++) u[o] = n[o];
  return u;
}
function ne(n) {
  if (Array.isArray(n)) return G(n);
}
function ie(n, t, o) {
  return (t = le(t)) in n ? Object.defineProperty(n, t, {
    value: o,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : n[t] = o, n;
}
function oe(n) {
  if (typeof Symbol < "u" && n[Symbol.iterator] != null || n["@@iterator"] != null) return Array.from(n);
}
function ue() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Q(n, t) {
  var o = Object.keys(n);
  if (Object.getOwnPropertySymbols) {
    var u = Object.getOwnPropertySymbols(n);
    t && (u = u.filter(function(m) {
      return Object.getOwnPropertyDescriptor(n, m).enumerable;
    })), o.push.apply(o, u);
  }
  return o;
}
function X(n) {
  for (var t = 1; t < arguments.length; t++) {
    var o = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Q(Object(o), !0).forEach(function(u) {
      ie(n, u, o[u]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(o)) : Q(Object(o)).forEach(function(u) {
      Object.defineProperty(n, u, Object.getOwnPropertyDescriptor(o, u));
    });
  }
  return n;
}
function se(n) {
  return ne(n) || oe(n) || fe(n) || ue();
}
function ce(n, t) {
  if (typeof n != "object" || !n) return n;
  var o = n[Symbol.toPrimitive];
  if (o !== void 0) {
    var u = o.call(n, t);
    if (typeof u != "object") return u;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(n);
}
function le(n) {
  var t = ce(n, "string");
  return typeof t == "symbol" ? t : t + "";
}
function fe(n, t) {
  if (n) {
    if (typeof n == "string") return G(n, t);
    var o = {}.toString.call(n).slice(8, -1);
    return o === "Object" && n.constructor && (o = n.constructor.name), o === "Map" || o === "Set" ? Array.from(n) : o === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(o) ? G(n, t) : void 0;
  }
}
var Z = {
  activateTrap: function(t, o) {
    if (t.length > 0) {
      var u = t[t.length - 1];
      u !== o && u._setPausedState(!0);
    }
    var m = t.indexOf(o);
    m === -1 || t.splice(m, 1), t.push(o);
  },
  deactivateTrap: function(t, o) {
    var u = t.indexOf(o);
    u !== -1 && t.splice(u, 1), t.length > 0 && !t[t.length - 1]._isManuallyPaused() && t[t.length - 1]._setPausedState(!1);
  }
}, de = function(t) {
  return t.tagName && t.tagName.toLowerCase() === "input" && typeof t.select == "function";
}, ve = function(t) {
  return t?.key === "Escape" || t?.key === "Esc" || t?.keyCode === 27;
}, L = function(t) {
  return t?.key === "Tab" || t?.keyCode === 9;
}, be = function(t) {
  return L(t) && !t.shiftKey;
}, pe = function(t) {
  return L(t) && t.shiftKey;
}, U = function(t) {
  return setTimeout(t, 0);
}, K = function(t) {
  for (var o = arguments.length, u = new Array(o > 1 ? o - 1 : 0), m = 1; m < o; m++)
    u[m - 1] = arguments[m];
  return typeof t == "function" ? t.apply(void 0, u) : t;
}, B = function(t) {
  return t.target.shadowRoot && typeof t.composedPath == "function" ? t.composedPath()[0] : t.target;
}, me = [], he = function(t, o) {
  var u = o?.document || document, m = o?.trapStack || me, f = X({
    returnFocusOnDeactivate: !0,
    escapeDeactivates: !0,
    delayInitialFocus: !0,
    isKeyForward: be,
    isKeyBackward: pe
  }, o), r = {
    // containers given to createFocusTrap()
    // @type {Array<HTMLElement>}
    containers: [],
    // list of objects identifying tabbable nodes in `containers` in the trap
    // NOTE: it's possible that a group has no tabbable nodes if nodes get removed while the trap
    //  is active, but the trap should never get to a state where there isn't at least one group
    //  with at least one tabbable node in it (that would lead to an error condition that would
    //  result in an error being thrown)
    // @type {Array<{
    //   container: HTMLElement,
    //   tabbableNodes: Array<HTMLElement>, // empty if none
    //   focusableNodes: Array<HTMLElement>, // empty if none
    //   posTabIndexesFound: boolean,
    //   firstTabbableNode: HTMLElement|undefined,
    //   lastTabbableNode: HTMLElement|undefined,
    //   firstDomTabbableNode: HTMLElement|undefined,
    //   lastDomTabbableNode: HTMLElement|undefined,
    //   nextTabbableNode: (node: HTMLElement, forward: boolean) => HTMLElement|undefined
    // }>}
    containerGroups: [],
    // same order/length as `containers` list
    // references to objects in `containerGroups`, but only those that actually have
    //  tabbable nodes in them
    // NOTE: same order as `containers` and `containerGroups`, but __not necessarily__
    //  the same length
    tabbableGroups: [],
    nodeFocusedBeforeActivation: null,
    mostRecentlyFocusedNode: null,
    active: !1,
    paused: !1,
    manuallyPaused: !1,
    // timer ID for when delayInitialFocus is true and initial focus in this trap
    //  has been delayed during activation
    delayInitialFocusTimer: void 0,
    // the most recent KeyboardEvent for the configured nav key (typically [SHIFT+]TAB), if any
    recentNavEvent: void 0
  }, h, y = function(e, a, i) {
    return e && e[a] !== void 0 ? e[a] : f[i || a];
  }, N = function(e, a) {
    var i = typeof a?.composedPath == "function" ? a.composedPath() : void 0;
    return r.containerGroups.findIndex(function(c) {
      var l = c.container, v = c.tabbableNodes;
      return l.contains(e) || i?.includes(l) || v.find(function(s) {
        return s === e;
      });
    });
  }, T = function(e) {
    var a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, i = a.hasFallback, c = i === void 0 ? !1 : i, l = a.params, v = l === void 0 ? [] : l, s = f[e];
    if (typeof s == "function" && (s = s.apply(void 0, se(v))), s === !0 && (s = void 0), !s) {
      if (s === void 0 || s === !1)
        return s;
      throw new Error("`".concat(e, "` was specified but was not a node, or did not return a node"));
    }
    var b = s;
    if (typeof s == "string") {
      try {
        b = u.querySelector(s);
      } catch (p) {
        throw new Error("`".concat(e, '` appears to be an invalid selector; error="').concat(p.message, '"'));
      }
      if (!b && !c)
        throw new Error("`".concat(e, "` as selector refers to no known node"));
    }
    return b;
  }, E = function() {
    var e = T("initialFocus", {
      hasFallback: !0
    });
    if (e === !1)
      return !1;
    if (e === void 0 || e && !x(e, f.tabbableOptions))
      if (N(u.activeElement) >= 0)
        e = u.activeElement;
      else {
        var a = r.tabbableGroups[0], i = a && a.firstTabbableNode;
        e = i || T("fallbackFocus");
      }
    else e === null && (e = T("fallbackFocus"));
    if (!e)
      throw new Error("Your focus-trap needs to have at least one focusable element");
    return e;
  }, P = function() {
    if (r.containerGroups = r.containers.map(function(e) {
      var a = ae(e, f.tabbableOptions), i = re(e, f.tabbableOptions), c = a.length > 0 ? a[0] : void 0, l = a.length > 0 ? a[a.length - 1] : void 0, v = i.find(function(p) {
        return k(p);
      }), s = i.slice().reverse().find(function(p) {
        return k(p);
      }), b = !!a.find(function(p) {
        return R(p) > 0;
      });
      return {
        container: e,
        tabbableNodes: a,
        focusableNodes: i,
        /** True if at least one node with positive `tabindex` was found in this container. */
        posTabIndexesFound: b,
        /** First tabbable node in container, __tabindex__ order; `undefined` if none. */
        firstTabbableNode: c,
        /** Last tabbable node in container, __tabindex__ order; `undefined` if none. */
        lastTabbableNode: l,
        // NOTE: DOM order is NOT NECESSARILY "document position" order, but figuring that out
        //  would require more than just https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition
        //  because that API doesn't work with Shadow DOM as well as it should (@see
        //  https://github.com/whatwg/dom/issues/320) and since this first/last is only needed, so far,
        //  to address an edge case related to positive tabindex support, this seems like a much easier,
        //  "close enough most of the time" alternative for positive tabindexes which should generally
        //  be avoided anyway...
        /** First tabbable node in container, __DOM__ order; `undefined` if none. */
        firstDomTabbableNode: v,
        /** Last tabbable node in container, __DOM__ order; `undefined` if none. */
        lastDomTabbableNode: s,
        /**
         * Finds the __tabbable__ node that follows the given node in the specified direction,
         *  in this container, if any.
         * @param {HTMLElement} node
         * @param {boolean} [forward] True if going in forward tab order; false if going
         *  in reverse.
         * @returns {HTMLElement|undefined} The next tabbable node, if any.
         */
        nextTabbableNode: function(F) {
          var O = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0, w = a.indexOf(F);
          return w < 0 ? O ? i.slice(i.indexOf(F) + 1).find(function(A) {
            return k(A);
          }) : i.slice(0, i.indexOf(F)).reverse().find(function(A) {
            return k(A);
          }) : a[w + (O ? 1 : -1)];
        }
      };
    }), r.tabbableGroups = r.containerGroups.filter(function(e) {
      return e.tabbableNodes.length > 0;
    }), r.tabbableGroups.length <= 0 && !T("fallbackFocus"))
      throw new Error("Your focus-trap must have at least one container with at least one tabbable node in it at all times");
    if (r.containerGroups.find(function(e) {
      return e.posTabIndexesFound;
    }) && r.containerGroups.length > 1)
      throw new Error("At least one node with a positive tabindex was found in one of your focus-trap's multiple containers. Positive tabindexes are only supported in single-container focus-traps.");
  }, C = function(e) {
    var a = e.activeElement;
    if (a)
      return a.shadowRoot && a.shadowRoot.activeElement !== null ? C(a.shadowRoot) : a;
  }, g = function(e) {
    if (e !== !1 && e !== C(document)) {
      if (!e || !e.focus) {
        g(E());
        return;
      }
      e.focus({
        preventScroll: !!f.preventScroll
      }), r.mostRecentlyFocusedNode = e, de(e) && e.select();
    }
  }, M = function(e) {
    var a = T("setReturnFocus", {
      params: [e]
    });
    return a || (a === !1 ? !1 : e);
  }, $ = function(e) {
    var a = e.target, i = e.event, c = e.isBackward, l = c === void 0 ? !1 : c;
    a = a || B(i), P();
    var v = null;
    if (r.tabbableGroups.length > 0) {
      var s = N(a, i), b = s >= 0 ? r.containerGroups[s] : void 0;
      if (s < 0)
        l ? v = r.tabbableGroups[r.tabbableGroups.length - 1].lastTabbableNode : v = r.tabbableGroups[0].firstTabbableNode;
      else if (l) {
        var p = r.tabbableGroups.findIndex(function(_) {
          var S = _.firstTabbableNode;
          return a === S;
        });
        if (p < 0 && (b.container === a || x(a, f.tabbableOptions) && !k(a, f.tabbableOptions) && !b.nextTabbableNode(a, !1)) && (p = s), p >= 0) {
          var F = p === 0 ? r.tabbableGroups.length - 1 : p - 1, O = r.tabbableGroups[F];
          v = R(a) >= 0 ? O.lastTabbableNode : O.lastDomTabbableNode;
        } else L(i) || (v = b.nextTabbableNode(a, !1));
      } else {
        var w = r.tabbableGroups.findIndex(function(_) {
          var S = _.lastTabbableNode;
          return a === S;
        });
        if (w < 0 && (b.container === a || x(a, f.tabbableOptions) && !k(a, f.tabbableOptions) && !b.nextTabbableNode(a)) && (w = s), w >= 0) {
          var A = w === r.tabbableGroups.length - 1 ? 0 : w + 1, J = r.tabbableGroups[A];
          v = R(a) >= 0 ? J.firstTabbableNode : J.firstDomTabbableNode;
        } else L(i) || (v = b.nextTabbableNode(a));
      }
    } else
      v = T("fallbackFocus");
    return v;
  }, j = function(e) {
    var a = B(e);
    if (!(N(a, e) >= 0)) {
      if (K(f.clickOutsideDeactivates, e)) {
        h.deactivate({
          // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,
          //  which will result in the outside click setting focus to the node
          //  that was clicked (and if not focusable, to "nothing"); by setting
          //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused
          //  on activation (or the configured `setReturnFocus` node), whether the
          //  outside click was on a focusable node or not
          returnFocus: f.returnFocusOnDeactivate
        });
        return;
      }
      K(f.allowOutsideClick, e) || e.preventDefault();
    }
  }, H = function(e) {
    var a = B(e), i = N(a, e) >= 0;
    if (i || a instanceof Document)
      i && (r.mostRecentlyFocusedNode = a);
    else {
      e.stopImmediatePropagation();
      var c, l = !0;
      if (r.mostRecentlyFocusedNode)
        if (R(r.mostRecentlyFocusedNode) > 0) {
          var v = N(r.mostRecentlyFocusedNode), s = r.containerGroups[v].tabbableNodes;
          if (s.length > 0) {
            var b = s.findIndex(function(p) {
              return p === r.mostRecentlyFocusedNode;
            });
            b >= 0 && (f.isKeyForward(r.recentNavEvent) ? b + 1 < s.length && (c = s[b + 1], l = !1) : b - 1 >= 0 && (c = s[b - 1], l = !1));
          }
        } else
          r.containerGroups.some(function(p) {
            return p.tabbableNodes.some(function(F) {
              return R(F) > 0;
            });
          }) || (l = !1);
      else
        l = !1;
      l && (c = $({
        // move FROM the MRU node, not event-related node (which will be the node that is
        //  outside the trap causing the focus escape we're trying to fix)
        target: r.mostRecentlyFocusedNode,
        isBackward: f.isKeyBackward(r.recentNavEvent)
      })), g(c || r.mostRecentlyFocusedNode || E());
    }
    r.recentNavEvent = void 0;
  }, ee = function(e) {
    var a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    r.recentNavEvent = e;
    var i = $({
      event: e,
      isBackward: a
    });
    i && (L(e) && e.preventDefault(), g(i));
  }, q = function(e) {
    (f.isKeyForward(e) || f.isKeyBackward(e)) && ee(e, f.isKeyBackward(e));
  }, Y = function(e) {
    ve(e) && K(f.escapeDeactivates, e) !== !1 && (e.preventDefault(), h.deactivate());
  }, V = function(e) {
    var a = B(e);
    N(a, e) >= 0 || K(f.clickOutsideDeactivates, e) || K(f.allowOutsideClick, e) || (e.preventDefault(), e.stopImmediatePropagation());
  }, W = function() {
    if (r.active)
      return Z.activateTrap(m, h), r.delayInitialFocusTimer = f.delayInitialFocus ? U(function() {
        g(E());
      }) : g(E()), u.addEventListener("focusin", H, !0), u.addEventListener("mousedown", j, {
        capture: !0,
        passive: !1
      }), u.addEventListener("touchstart", j, {
        capture: !0,
        passive: !1
      }), u.addEventListener("click", V, {
        capture: !0,
        passive: !1
      }), u.addEventListener("keydown", q, {
        capture: !0,
        passive: !1
      }), u.addEventListener("keydown", Y), h;
  }, z = function() {
    if (r.active)
      return u.removeEventListener("focusin", H, !0), u.removeEventListener("mousedown", j, !0), u.removeEventListener("touchstart", j, !0), u.removeEventListener("click", V, !0), u.removeEventListener("keydown", q, !0), u.removeEventListener("keydown", Y), h;
  }, te = function(e) {
    var a = e.some(function(i) {
      var c = Array.from(i.removedNodes);
      return c.some(function(l) {
        return l === r.mostRecentlyFocusedNode;
      });
    });
    a && g(E());
  }, I = typeof window < "u" && "MutationObserver" in window ? new MutationObserver(te) : void 0, D = function() {
    I && (I.disconnect(), r.active && !r.paused && r.containers.map(function(e) {
      I.observe(e, {
        subtree: !0,
        childList: !0
      });
    }));
  };
  return h = {
    get active() {
      return r.active;
    },
    get paused() {
      return r.paused;
    },
    activate: function(e) {
      if (r.active)
        return this;
      var a = y(e, "onActivate"), i = y(e, "onPostActivate"), c = y(e, "checkCanFocusTrap");
      c || P(), r.active = !0, r.paused = !1, r.nodeFocusedBeforeActivation = C(u), a?.();
      var l = function() {
        c && P(), W(), D(), i?.();
      };
      return c ? (c(r.containers.concat()).then(l, l), this) : (l(), this);
    },
    deactivate: function(e) {
      if (!r.active)
        return this;
      var a = X({
        onDeactivate: f.onDeactivate,
        onPostDeactivate: f.onPostDeactivate,
        checkCanReturnFocus: f.checkCanReturnFocus
      }, e);
      clearTimeout(r.delayInitialFocusTimer), r.delayInitialFocusTimer = void 0, z(), r.active = !1, r.paused = !1, D(), Z.deactivateTrap(m, h);
      var i = y(a, "onDeactivate"), c = y(a, "onPostDeactivate"), l = y(a, "checkCanReturnFocus"), v = y(a, "returnFocus", "returnFocusOnDeactivate");
      i?.();
      var s = function() {
        U(function() {
          v && g(M(r.nodeFocusedBeforeActivation)), c?.();
        });
      };
      return v && l ? (l(M(r.nodeFocusedBeforeActivation)).then(s, s), this) : (s(), this);
    },
    pause: function(e) {
      return r.active ? (r.manuallyPaused = !0, this._setPausedState(!0, e)) : this;
    },
    unpause: function(e) {
      return r.active ? (r.manuallyPaused = !1, m[m.length - 1] !== this ? this : this._setPausedState(!1, e)) : this;
    },
    updateContainerElements: function(e) {
      var a = [].concat(e).filter(Boolean);
      return r.containers = a.map(function(i) {
        return typeof i == "string" ? u.querySelector(i) : i;
      }), r.active && P(), D(), this;
    }
  }, Object.defineProperties(h, {
    _isManuallyPaused: {
      value: function() {
        return r.manuallyPaused;
      }
    },
    _setPausedState: {
      value: function(e, a) {
        if (r.paused === e)
          return this;
        if (r.paused = e, e) {
          var i = y(a, "onPause"), c = y(a, "onPostPause");
          i?.(), z(), D(), c?.();
        } else {
          var l = y(a, "onUnpause"), v = y(a, "onPostUnpause");
          l?.(), P(), W(), D(), v?.();
        }
        return this;
      }
    }
  }), h.updateContainerElements(t), h;
};
export {
  he as createFocusTrap
};
//# sourceMappingURL=focus-trap.esm.js.map

import K from "react";
import { __require as x } from "../../prop-types/index.js";
import z from "../../../_virtual/focus-trap.esm.js";
import M from "../../../_virtual/index.esm.js";
var T, k;
function H() {
  if (k) return T;
  k = 1;
  function f(i) {
    "@babel/helpers - typeof";
    return f = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
      return typeof t;
    } : function(t) {
      return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
    }, f(i);
  }
  function E(i, t) {
    if (!(i instanceof t)) throw new TypeError("Cannot call a class as a function");
  }
  function P(i, t) {
    for (var o = 0; o < t.length; o++) {
      var e = t[o];
      e.enumerable = e.enumerable || !1, e.configurable = !0, "value" in e && (e.writable = !0), Object.defineProperty(i, g(e.key), e);
    }
  }
  function w(i, t, o) {
    return t && P(i.prototype, t), Object.defineProperty(i, "prototype", { writable: !1 }), i;
  }
  function C(i, t, o) {
    return t = v(t), _(i, D() ? Reflect.construct(t, o || [], v(i).constructor) : t.apply(i, o));
  }
  function _(i, t) {
    if (t && (f(t) == "object" || typeof t == "function")) return t;
    if (t !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
    return R(i);
  }
  function R(i) {
    if (i === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return i;
  }
  function D() {
    try {
      var i = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
    } catch {
    }
    return (D = function() {
      return !!i;
    })();
  }
  function v(i) {
    return v = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
      return t.__proto__ || Object.getPrototypeOf(t);
    }, v(i);
  }
  function j(i, t) {
    if (typeof t != "function" && t !== null) throw new TypeError("Super expression must either be null or a function");
    i.prototype = Object.create(t && t.prototype, { constructor: { value: i, writable: !0, configurable: !0 } }), Object.defineProperty(i, "prototype", { writable: !1 }), t && y(i, t);
  }
  function y(i, t) {
    return y = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(o, e) {
      return o.__proto__ = e, o;
    }, y(i, t);
  }
  function S(i, t, o) {
    return (t = g(t)) in i ? Object.defineProperty(i, t, { value: o, enumerable: !0, configurable: !0, writable: !0 }) : i[t] = o, i;
  }
  function g(i) {
    var t = q(i, "string");
    return f(t) == "symbol" ? t : t + "";
  }
  function q(i, t) {
    if (f(i) != "object" || !i) return i;
    var o = i[Symbol.toPrimitive];
    if (o !== void 0) {
      var e = o.call(i, t);
      if (f(e) != "object") return e;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (t === "string" ? String : Number)(i);
  }
  var d = K, n = /* @__PURE__ */ x(), U = z, A = U.createFocusTrap, B = M, $ = B.isFocusable, O = /* @__PURE__ */ function(i) {
    function t(o) {
      var e;
      E(this, t), e = C(this, t, [o]), S(e, "getNodeForOption", function(s) {
        var u, a = (u = this.internalOptions[s]) !== null && u !== void 0 ? u : this.originalOptions[s];
        if (typeof a == "function") {
          for (var l = arguments.length, F = new Array(l > 1 ? l - 1 : 0), h = 1; h < l; h++)
            F[h - 1] = arguments[h];
          a = a.apply(void 0, F);
        }
        if (a === !0 && (a = void 0), !a) {
          if (a === void 0 || a === !1)
            return a;
          throw new Error("`".concat(s, "` was specified but was not a node, or did not return a node"));
        }
        var b = a;
        if (typeof a == "string") {
          var m;
          if (b = (m = this.getDocument()) === null || m === void 0 ? void 0 : m.querySelector(a), !b)
            throw new Error("`".concat(s, "` as selector refers to no known node"));
        }
        return b;
      }), e.handleDeactivate = e.handleDeactivate.bind(e), e.handlePostDeactivate = e.handlePostDeactivate.bind(e), e.handleClickOutsideDeactivates = e.handleClickOutsideDeactivates.bind(e), e.internalOptions = {
        // We need to hijack the returnFocusOnDeactivate option,
        // because React can move focus into the element before we arrived at
        // this lifecycle hook (e.g. with autoFocus inputs). So the component
        // captures the previouslyFocusedElement in componentWillMount,
        // then (optionally) returns focus to it in componentWillUnmount.
        returnFocusOnDeactivate: !1,
        // the rest of these are also related to deactivation of the trap, and we
        //  need to use them and control them as well
        checkCanReturnFocus: null,
        onDeactivate: e.handleDeactivate,
        onPostDeactivate: e.handlePostDeactivate,
        // we need to special-case this setting as well so that we can know if we should
        //  NOT return focus if the trap gets auto-deactivated as the result of an
        //  outside click (otherwise, we'll always think we should return focus because
        //  of how we manage that flag internally here)
        clickOutsideDeactivates: e.handleClickOutsideDeactivates
      }, e.originalOptions = {
        // because of the above `internalOptions`, we maintain our own flag for
        //  this option, and default it to `true` because that's focus-trap's default
        returnFocusOnDeactivate: !0,
        // because of the above `internalOptions`, we keep these separate since
        //  they're part of the deactivation process which we configure (internally) to
        //  be shared between focus-trap and focus-trap-react
        onDeactivate: null,
        onPostDeactivate: null,
        checkCanReturnFocus: null,
        // the user's setting, defaulted to false since focus-trap defaults this to false
        clickOutsideDeactivates: !1
      };
      var r = o.focusTrapOptions;
      for (var c in r)
        if (Object.prototype.hasOwnProperty.call(r, c)) {
          if (c === "returnFocusOnDeactivate" || c === "onDeactivate" || c === "onPostDeactivate" || c === "checkCanReturnFocus" || c === "clickOutsideDeactivates") {
            e.originalOptions[c] = r[c];
            continue;
          }
          e.internalOptions[c] = r[c];
        }
      return e.outsideClick = null, e.focusTrapElements = o.containerElements || [], e.updatePreviousElement(), e;
    }
    return j(t, i), w(t, [{
      key: "getDocument",
      value: function() {
        return this.props.focusTrapOptions.document || (typeof document < "u" ? document : void 0);
      }
    }, {
      key: "getReturnFocusNode",
      value: function() {
        var e = this.getNodeForOption("setReturnFocus", this.previouslyFocusedElement);
        return e || (e === !1 ? !1 : this.previouslyFocusedElement);
      }
      /** Update the previously focused element with the currently focused element. */
    }, {
      key: "updatePreviousElement",
      value: function() {
        var e = this.getDocument();
        e && (this.previouslyFocusedElement = e.activeElement);
      }
    }, {
      key: "deactivateTrap",
      value: function() {
        !this.focusTrap || !this.focusTrap.active || this.focusTrap.deactivate({
          // NOTE: we never let the trap return the focus since we do that ourselves
          returnFocus: !1,
          // we'll call this in our own post deactivate handler so make sure the trap doesn't
          //  do it prematurely
          checkCanReturnFocus: null,
          // let it call the user's original deactivate handler, if any, instead of
          //  our own which calls back into this function
          onDeactivate: this.originalOptions.onDeactivate
          // NOTE: for post deactivate, don't specify anything so that it calls the
          //  onPostDeactivate handler specified on `this.internalOptions`
          //  which will always be our own `handlePostDeactivate()` handler, which
          //  will finish things off by calling the user's provided onPostDeactivate
          //  handler, if any, at the right time
          // onPostDeactivate: NOTHING
        });
      }
    }, {
      key: "handleClickOutsideDeactivates",
      value: function(e) {
        var r = typeof this.originalOptions.clickOutsideDeactivates == "function" ? this.originalOptions.clickOutsideDeactivates.call(null, e) : this.originalOptions.clickOutsideDeactivates;
        return r && (this.outsideClick = {
          target: e.target,
          allowDeactivation: r
        }), r;
      }
    }, {
      key: "handleDeactivate",
      value: function() {
        this.originalOptions.onDeactivate && this.originalOptions.onDeactivate.call(null), this.deactivateTrap();
      }
    }, {
      key: "handlePostDeactivate",
      value: function() {
        var e = this, r = function() {
          var s = e.getReturnFocusNode(), u = !!// did the consumer allow it?
          (e.originalOptions.returnFocusOnDeactivate && // can we actually focus the node?
          s !== null && s !== void 0 && s.focus && // was there an outside click that allowed deactivation?
          (!e.outsideClick || // did the consumer allow deactivation when the outside node was clicked?
          e.outsideClick.allowDeactivation && // is the outside node NOT focusable (implying that it did NOT receive focus
          //  as a result of the click-through) -- in which case do NOT restore focus
          //  to `returnFocusNode` because focus should remain on the outside node
          !$(e.outsideClick.target, e.internalOptions.tabbableOptions))), a = e.internalOptions.preventScroll, l = a === void 0 ? !1 : a;
          u && s.focus({
            preventScroll: l
          }), e.originalOptions.onPostDeactivate && e.originalOptions.onPostDeactivate.call(null), e.outsideClick = null;
        };
        this.originalOptions.checkCanReturnFocus ? this.originalOptions.checkCanReturnFocus.call(null, this.getReturnFocusNode()).then(r, r) : r();
      }
    }, {
      key: "setupFocusTrap",
      value: function() {
        if (this.focusTrap)
          this.props.active && !this.focusTrap.active && (this.focusTrap.activate(), this.props.paused && this.focusTrap.pause());
        else {
          var e = this.focusTrapElements.some(Boolean);
          e && (this.focusTrap = this.props._createFocusTrap(this.focusTrapElements, this.internalOptions), this.props.active && this.focusTrap.activate(), this.props.paused && this.focusTrap.pause());
        }
      }
    }, {
      key: "componentDidMount",
      value: function() {
        this.props.active && this.setupFocusTrap();
      }
    }, {
      key: "componentDidUpdate",
      value: function(e) {
        if (this.focusTrap) {
          e.containerElements !== this.props.containerElements && this.focusTrap.updateContainerElements(this.props.containerElements);
          var r = !e.active && this.props.active, c = e.active && !this.props.active, s = !e.paused && this.props.paused, u = e.paused && !this.props.paused;
          if (r && (this.updatePreviousElement(), this.focusTrap.activate()), c) {
            this.deactivateTrap();
            return;
          }
          s && this.focusTrap.pause(), u && this.focusTrap.unpause();
        } else
          e.containerElements !== this.props.containerElements && (this.focusTrapElements = this.props.containerElements), this.props.active && (this.updatePreviousElement(), this.setupFocusTrap());
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        this.deactivateTrap();
      }
    }, {
      key: "render",
      value: function() {
        var e = this, r = this.props.children ? d.Children.only(this.props.children) : void 0;
        if (r) {
          if (r.type && r.type === d.Fragment)
            throw new Error("A focus-trap cannot use a Fragment as its child container. Try replacing it with a <div> element.");
          var c = function(a) {
            var l = e.props.containerElements;
            r && (typeof r.ref == "function" ? r.ref(a) : r.ref && (r.ref.current = a)), e.focusTrapElements = l || [a];
          }, s = d.cloneElement(r, {
            ref: c
          });
          return s;
        }
        return null;
      }
    }]);
  }(d.Component), p = typeof Element > "u" ? Function : Element;
  return O.propTypes = {
    active: n.bool,
    paused: n.bool,
    focusTrapOptions: n.shape({
      document: n.object,
      onActivate: n.func,
      onPostActivate: n.func,
      checkCanFocusTrap: n.func,
      onPause: n.func,
      onPostPause: n.func,
      onUnpause: n.func,
      onPostUnpause: n.func,
      onDeactivate: n.func,
      onPostDeactivate: n.func,
      checkCanReturnFocus: n.func,
      initialFocus: n.oneOfType([n.instanceOf(p), n.string, n.bool, n.func]),
      fallbackFocus: n.oneOfType([
        n.instanceOf(p),
        n.string,
        // NOTE: does not support `false` as value (or return value from function)
        n.func
      ]),
      escapeDeactivates: n.oneOfType([n.bool, n.func]),
      clickOutsideDeactivates: n.oneOfType([n.bool, n.func]),
      returnFocusOnDeactivate: n.bool,
      setReturnFocus: n.oneOfType([n.instanceOf(p), n.string, n.bool, n.func]),
      allowOutsideClick: n.oneOfType([n.bool, n.func]),
      preventScroll: n.bool,
      tabbableOptions: n.shape({
        displayCheck: n.oneOf(["full", "legacy-full", "non-zero-area", "none"]),
        getShadowRoot: n.oneOfType([n.bool, n.func])
      }),
      trapStack: n.array,
      isKeyForward: n.func,
      isKeyBackward: n.func
    }),
    containerElements: n.arrayOf(n.instanceOf(p)),
    // DOM element ONLY
    children: n.oneOfType([
      n.element,
      // React element
      n.instanceOf(p)
      // DOM element
    ])
    // NOTE: _createFocusTrap is internal, for testing purposes only, so we don't
    //  specify it here. It's expected to be set to the function returned from
    //  require('focus-trap'), or one with a compatible interface.
  }, O.defaultProps = {
    active: !0,
    paused: !1,
    focusTrapOptions: {},
    _createFocusTrap: A
  }, T = O, T;
}
export {
  H as __require
};
//# sourceMappingURL=focus-trap-react.js.map

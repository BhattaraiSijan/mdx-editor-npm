{"version":3,"file":"safe.js","sources":["../../../../../../../node_modules/mdast-util-to-markdown/lib/util/safe.js"],"sourcesContent":["/**\n * @import {SafeConfig, State} from 'mdast-util-to-markdown'\n */\n\nimport {encodeCharacterReference} from './encode-character-reference.js'\nimport {patternInScope} from './pattern-in-scope.js'\n\n/**\n * Make a string safe for embedding in markdown constructs.\n *\n * In markdown, almost all punctuation characters can, in certain cases,\n * result in something.\n * Whether they do is highly subjective to where they happen and in what\n * they happen.\n *\n * To solve this, `mdast-util-to-markdown` tracks:\n *\n * * Characters before and after something;\n * * What “constructs” we are in.\n *\n * This information is then used by this function to escape or encode\n * special characters.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {string | null | undefined} input\n *   Raw value to make safe.\n * @param {SafeConfig} config\n *   Configuration.\n * @returns {string}\n *   Serialized markdown safe for embedding.\n */\nexport function safe(state, input, config) {\n  const value = (config.before || '') + (input || '') + (config.after || '')\n  /** @type {Array<number>} */\n  const positions = []\n  /** @type {Array<string>} */\n  const result = []\n  /** @type {Record<number, {before: boolean, after: boolean}>} */\n  const infos = {}\n  let index = -1\n\n  while (++index < state.unsafe.length) {\n    const pattern = state.unsafe[index]\n\n    if (!patternInScope(state.stack, pattern)) {\n      continue\n    }\n\n    const expression = state.compilePattern(pattern)\n    /** @type {RegExpExecArray | null} */\n    let match\n\n    while ((match = expression.exec(value))) {\n      const before = 'before' in pattern || Boolean(pattern.atBreak)\n      const after = 'after' in pattern\n      const position = match.index + (before ? match[1].length : 0)\n\n      if (positions.includes(position)) {\n        if (infos[position].before && !before) {\n          infos[position].before = false\n        }\n\n        if (infos[position].after && !after) {\n          infos[position].after = false\n        }\n      } else {\n        positions.push(position)\n        infos[position] = {before, after}\n      }\n    }\n  }\n\n  positions.sort(numerical)\n\n  let start = config.before ? config.before.length : 0\n  const end = value.length - (config.after ? config.after.length : 0)\n  index = -1\n\n  while (++index < positions.length) {\n    const position = positions[index]\n\n    // Character before or after matched:\n    if (position < start || position >= end) {\n      continue\n    }\n\n    // If this character is supposed to be escaped because it has a condition on\n    // the next character, and the next character is definitly being escaped,\n    // then skip this escape.\n    if (\n      (position + 1 < end &&\n        positions[index + 1] === position + 1 &&\n        infos[position].after &&\n        !infos[position + 1].before &&\n        !infos[position + 1].after) ||\n      (positions[index - 1] === position - 1 &&\n        infos[position].before &&\n        !infos[position - 1].before &&\n        !infos[position - 1].after)\n    ) {\n      continue\n    }\n\n    if (start !== position) {\n      // If we have to use a character reference, an ampersand would be more\n      // correct, but as backslashes only care about punctuation, either will\n      // do the trick\n      result.push(escapeBackslashes(value.slice(start, position), '\\\\'))\n    }\n\n    start = position\n\n    if (\n      /[!-/:-@[-`{-~]/.test(value.charAt(position)) &&\n      (!config.encode || !config.encode.includes(value.charAt(position)))\n    ) {\n      // Character escape.\n      result.push('\\\\')\n    } else {\n      // Character reference.\n      result.push(encodeCharacterReference(value.charCodeAt(position)))\n      start++\n    }\n  }\n\n  result.push(escapeBackslashes(value.slice(start, end), config.after))\n\n  return result.join('')\n}\n\n/**\n * @param {number} a\n * @param {number} b\n * @returns {number}\n */\nfunction numerical(a, b) {\n  return a - b\n}\n\n/**\n * @param {string} value\n * @param {string} after\n * @returns {string}\n */\nfunction escapeBackslashes(value, after) {\n  const expression = /\\\\(?=[!-/:-@[-`{-~])/g\n  /** @type {Array<number>} */\n  const positions = []\n  /** @type {Array<string>} */\n  const results = []\n  const whole = value + after\n  let index = -1\n  let start = 0\n  /** @type {RegExpExecArray | null} */\n  let match\n\n  while ((match = expression.exec(whole))) {\n    positions.push(match.index)\n  }\n\n  while (++index < positions.length) {\n    if (start !== positions[index]) {\n      results.push(value.slice(start, positions[index]))\n    }\n\n    results.push('\\\\')\n    start = positions[index]\n  }\n\n  results.push(value.slice(start))\n\n  return results.join('')\n}\n"],"names":["safe","state","input","config","value","positions","result","infos","index","pattern","patternInScope","expression","match","before","after","position","numerical","start","end","escapeBackslashes","encodeCharacterReference","a","b","results","whole"],"mappings":"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","x_google_ignoreList":[0]}
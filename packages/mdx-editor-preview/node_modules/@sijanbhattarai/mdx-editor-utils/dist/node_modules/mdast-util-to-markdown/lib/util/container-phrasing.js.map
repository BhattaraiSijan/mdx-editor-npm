{"version":3,"file":"container-phrasing.js","sources":["../../../../../../../node_modules/mdast-util-to-markdown/lib/util/container-phrasing.js"],"sourcesContent":["/**\n * @import {Handle, Info, State} from 'mdast-util-to-markdown'\n * @import {PhrasingParents} from '../types.js'\n */\n\nimport {encodeCharacterReference} from './encode-character-reference.js'\n\n/**\n * Serialize the children of a parent that contains phrasing children.\n *\n * These children will be joined flush together.\n *\n * @param {PhrasingParents} parent\n *   Parent of flow nodes.\n * @param {State} state\n *   Info passed around about the current state.\n * @param {Info} info\n *   Info on where we are in the document we are generating.\n * @returns {string}\n *   Serialized children, joined together.\n */\nexport function containerPhrasing(parent, state, info) {\n  const indexStack = state.indexStack\n  const children = parent.children || []\n  /** @type {Array<string>} */\n  const results = []\n  let index = -1\n  let before = info.before\n  /** @type {string | undefined} */\n  let encodeAfter\n\n  indexStack.push(-1)\n  let tracker = state.createTracker(info)\n\n  while (++index < children.length) {\n    const child = children[index]\n    /** @type {string} */\n    let after\n\n    indexStack[indexStack.length - 1] = index\n\n    if (index + 1 < children.length) {\n      /** @type {Handle} */\n      // @ts-expect-error: hush, it’s actually a `zwitch`.\n      let handle = state.handle.handlers[children[index + 1].type]\n      /** @type {Handle} */\n      // @ts-expect-error: hush, it’s actually a `zwitch`.\n      if (handle && handle.peek) handle = handle.peek\n      after = handle\n        ? handle(children[index + 1], parent, state, {\n            before: '',\n            after: '',\n            ...tracker.current()\n          }).charAt(0)\n        : ''\n    } else {\n      after = info.after\n    }\n\n    // In some cases, html (text) can be found in phrasing right after an eol.\n    // When we’d serialize that, in most cases that would be seen as html\n    // (flow).\n    // As we can’t escape or so to prevent it from happening, we take a somewhat\n    // reasonable approach: replace that eol with a space.\n    // See: <https://github.com/syntax-tree/mdast-util-to-markdown/issues/15>\n    if (\n      results.length > 0 &&\n      (before === '\\r' || before === '\\n') &&\n      child.type === 'html'\n    ) {\n      results[results.length - 1] = results[results.length - 1].replace(\n        /(\\r?\\n|\\r)$/,\n        ' '\n      )\n      before = ' '\n\n      // To do: does this work to reset tracker?\n      tracker = state.createTracker(info)\n      tracker.move(results.join(''))\n    }\n\n    let value = state.handle(child, parent, state, {\n      ...tracker.current(),\n      after,\n      before\n    })\n\n    // If we had to encode the first character after the previous node and it’s\n    // still the same character,\n    // encode it.\n    if (encodeAfter && encodeAfter === value.slice(0, 1)) {\n      value =\n        encodeCharacterReference(encodeAfter.charCodeAt(0)) + value.slice(1)\n    }\n\n    const encodingInfo = state.attentionEncodeSurroundingInfo\n    state.attentionEncodeSurroundingInfo = undefined\n    encodeAfter = undefined\n\n    // If we have to encode the first character before the current node and\n    // it’s still the same character,\n    // encode it.\n    if (encodingInfo) {\n      if (\n        results.length > 0 &&\n        encodingInfo.before &&\n        before === results[results.length - 1].slice(-1)\n      ) {\n        results[results.length - 1] =\n          results[results.length - 1].slice(0, -1) +\n          encodeCharacterReference(before.charCodeAt(0))\n      }\n\n      if (encodingInfo.after) encodeAfter = after\n    }\n\n    tracker.move(value)\n    results.push(value)\n    before = value.slice(-1)\n  }\n\n  indexStack.pop()\n\n  return results.join('')\n}\n"],"names":["containerPhrasing","parent","state","info","indexStack","children","results","index","before","encodeAfter","tracker","child","after","handle","value","encodeCharacterReference","encodingInfo"],"mappings":";AAqBO,SAASA,EAAkBC,GAAQC,GAAOC,GAAM;AACrD,QAAMC,IAAaF,EAAM,YACnBG,IAAWJ,EAAO,YAAY,CAAA,GAE9BK,IAAU,CAAA;AAChB,MAAIC,IAAQ,IACRC,IAASL,EAAK,QAEdM;AAEJ,EAAAL,EAAW,KAAK,EAAE;AAClB,MAAIM,IAAUR,EAAM,cAAcC,CAAI;AAEtC,SAAO,EAAEI,IAAQF,EAAS,UAAQ;AAChC,UAAMM,IAAQN,EAASE,CAAK;AAE5B,QAAIK;AAIJ,QAFAR,EAAWA,EAAW,SAAS,CAAC,IAAIG,GAEhCA,IAAQ,IAAIF,EAAS,QAAQ;AAG/B,UAAIQ,IAASX,EAAM,OAAO,SAASG,EAASE,IAAQ,CAAC,EAAE,IAAI;AAG3D,MAAIM,KAAUA,EAAO,SAAMA,IAASA,EAAO,OAC3CD,IAAQC,IACJA,EAAOR,EAASE,IAAQ,CAAC,GAAGN,GAAQC,GAAO;AAAA,QACzC,QAAQ;AAAA,QACR,OAAO;AAAA,QACP,GAAGQ,EAAQ,QAAO;AAAA,MAC9B,CAAW,EAAE,OAAO,CAAC,IACX;AAAA,IACN;AACE,MAAAE,IAAQT,EAAK;AASf,IACEG,EAAQ,SAAS,MAChBE,MAAW,QAAQA,MAAW;AAAA,MAC/BG,EAAM,SAAS,WAEfL,EAAQA,EAAQ,SAAS,CAAC,IAAIA,EAAQA,EAAQ,SAAS,CAAC,EAAE;AAAA,MACxD;AAAA,MACA;AAAA,IACR,GACME,IAAS,KAGTE,IAAUR,EAAM,cAAcC,CAAI,GAClCO,EAAQ,KAAKJ,EAAQ,KAAK,EAAE,CAAC;AAG/B,QAAIQ,IAAQZ,EAAM,OAAOS,GAAOV,GAAQC,GAAO;AAAA,MAC7C,GAAGQ,EAAQ,QAAO;AAAA,MAClB,OAAAE;AAAA,MACA,QAAAJ;AAAA,IACN,CAAK;AAKD,IAAIC,KAAeA,MAAgBK,EAAM,MAAM,GAAG,CAAC,MACjDA,IACEC,EAAyBN,EAAY,WAAW,CAAC,CAAC,IAAIK,EAAM,MAAM,CAAC;AAGvE,UAAME,IAAed,EAAM;AAC3B,IAAAA,EAAM,iCAAiC,QACvCO,IAAc,QAKVO,MAEAV,EAAQ,SAAS,KACjBU,EAAa,UACbR,MAAWF,EAAQA,EAAQ,SAAS,CAAC,EAAE,MAAM,EAAE,MAE/CA,EAAQA,EAAQ,SAAS,CAAC,IACxBA,EAAQA,EAAQ,SAAS,CAAC,EAAE,MAAM,GAAG,EAAE,IACvCS,EAAyBP,EAAO,WAAW,CAAC,CAAC,IAG7CQ,EAAa,UAAOP,IAAcG,KAGxCF,EAAQ,KAAKI,CAAK,GAClBR,EAAQ,KAAKQ,CAAK,GAClBN,IAASM,EAAM,MAAM,EAAE;AAAA,EACzB;AAEA,SAAAV,EAAW,IAAG,GAEPE,EAAQ,KAAK,EAAE;AACxB;","x_google_ignoreList":[0]}
{"version":3,"file":"groupElements.js","sources":["../src/groupElements.tsx"],"sourcesContent":["import { handleTwoColumn } from './parseTwoColumn';\nimport { wrapComponent } from './wrapComponent';\n\nexport const groupByBreakIntoBlocks = (ast) => {\n  const result: any = [];\n  const proseWrapper = (children) => {\n    return {\n      type: 'mdxJsxFlowElement',\n      name: 'Prose',\n      children: [...children],\n    };\n  };\n\n  const groupChildren = (children) => {\n    const groups: any = [];\n    let currentGroup: any = [];\n\n    for (const child of children) {\n      if (\n        child.type === 'mdxJsxTextElement' ||\n        child.type === 'mdxJsxFlowElement'\n      ) {\n        if (child.name === 'Break') {\n          if (currentGroup.length > 0) {\n            groups.push([proseWrapper(currentGroup)]);\n            currentGroup = [];\n          }\n        } else if (\n          child.name === 'Block' ||\n          child.name === 'Chart' ||\n          child.name === 'Map' ||\n          child.name === 'TwoColumn'\n        ) {\n          groups.push([proseWrapper(currentGroup)]);\n\n          if (child.name === 'Chart' || child.name === 'Map') {\n            groups.push([wrapComponent(child)]);\n          } else if (child.name === 'TwoColumn') {\n            const parsedColumn = handleTwoColumn(child);\n            groups.push(parsedColumn);\n          }\n          currentGroup = [];\n        }\n      } else {\n        currentGroup.push(child);\n      }\n    }\n\n    if (currentGroup.length > 0) {\n      groups.push([...currentGroup]);\n    }\n    return groups;\n  };\n\n  if (ast.type === 'root' && Array.isArray(ast.children)) {\n    const groups = groupChildren(ast.children);\n\n    for (const group of groups) {\n      // Check for prose wrapper inside group If no prose wrapper\n      // then wrap group inside prose object before adding to block element\n\n      if (\n        group.some((item) => {\n          return item.name === 'Prose';\n        })\n      ) {\n        result.push({\n          type: 'mdxJsxFlowElement',\n          name: 'Block',\n          children: [...group],\n        });\n      } else {\n        result.push({\n          type: 'mdxJsxFlowElement',\n          name: 'Block',\n          children: [\n            {\n              type: 'mdxJsxFlowElement',\n              name: 'Prose',\n              children: [...group],\n            },\n          ],\n        });\n      }\n    }\n  }\n\n  return result;\n};\n"],"names":["groupByBreakIntoBlocks","ast","result","proseWrapper","children","groupChildren","groups","currentGroup","child","wrapComponent","parsedColumn","handleTwoColumn","group","item"],"mappings":";;AAGO,MAAMA,IAAyB,CAACC,MAAQ;AAC7C,QAAMC,IAAc,CAAA,GACdC,IAAe,CAACC,OACb;AAAA,IACL,MAAM;AAAA,IACN,MAAM;AAAA,IACN,UAAU,CAAC,GAAGA,CAAQ;AAAA,EAAA,IAIpBC,IAAgB,CAACD,MAAa;AAClC,UAAME,IAAc,CAAA;AACpB,QAAIC,IAAoB,CAAA;AAExB,eAAWC,KAASJ;AAClB,UACEI,EAAM,SAAS,uBACfA,EAAM,SAAS;AAEf,YAAIA,EAAM,SAAS;AACjB,UAAID,EAAa,SAAS,MACxBD,EAAO,KAAK,CAACH,EAAaI,CAAY,CAAC,CAAC,GACxCA,IAAe,CAAA;AAAA,iBAGjBC,EAAM,SAAS,WACfA,EAAM,SAAS,WACfA,EAAM,SAAS,SACfA,EAAM,SAAS,aACf;AAGA,cAFAF,EAAO,KAAK,CAACH,EAAaI,CAAY,CAAC,CAAC,GAEpCC,EAAM,SAAS,WAAWA,EAAM,SAAS;AAC3C,YAAAF,EAAO,KAAK,CAACG,EAAcD,CAAK,CAAC,CAAC;AAAA,mBACzBA,EAAM,SAAS,aAAa;AACrC,kBAAME,IAAeC,EAAgBH,CAAK;AAC1C,YAAAF,EAAO,KAAKI,CAAY;AAAA,UAC1B;AACA,UAAAH,IAAe,CAAA;AAAA,QACjB;AAAA;AAEA,QAAAA,EAAa,KAAKC,CAAK;AAI3B,WAAID,EAAa,SAAS,KACxBD,EAAO,KAAK,CAAC,GAAGC,CAAY,CAAC,GAExBD;AAAA,EACT;AAEA,MAAIL,EAAI,SAAS,UAAU,MAAM,QAAQA,EAAI,QAAQ,GAAG;AACtD,UAAMK,IAASD,EAAcJ,EAAI,QAAQ;AAEzC,eAAWW,KAASN;AAIlB,MACEM,EAAM,KAAK,CAACC,MACHA,EAAK,SAAS,OACtB,IAEDX,EAAO,KAAK;AAAA,QACV,MAAM;AAAA,QACN,MAAM;AAAA,QACN,UAAU,CAAC,GAAGU,CAAK;AAAA,MAAA,CACpB,IAEDV,EAAO,KAAK;AAAA,QACV,MAAM;AAAA,QACN,MAAM;AAAA,QACN,UAAU;AAAA,UACR;AAAA,YACE,MAAM;AAAA,YACN,MAAM;AAAA,YACN,UAAU,CAAC,GAAGU,CAAK;AAAA,UAAA;AAAA,QACrB;AAAA,MACF,CACD;AAAA,EAGP;AAEA,SAAOV;AACT;"}
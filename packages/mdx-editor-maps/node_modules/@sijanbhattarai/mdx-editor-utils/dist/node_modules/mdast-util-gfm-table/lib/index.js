import { markdownTable as p } from "../../markdown-table/index.js";
import { handle as x } from "../../mdast-util-to-markdown/lib/handle/index.js";
function R(m) {
  const c = {}, o = c.tableCellPadding, d = c.tablePipeAlign, f = c.stringLength, s = o ? " " : "|";
  return {
    unsafe: [
      { character: "\r", inConstruct: "tableCell" },
      { character: `
`, inConstruct: "tableCell" },
      // A pipe, when followed by a tab or space (padding), or a dash or colon
      // (unpadded delimiter row), could result in a table.
      { atBreak: !0, character: "|", after: "[	 :-]" },
      // A pipe in a cell must be encoded.
      { character: "|", inConstruct: "tableCell" },
      // A colon must be followed by a dash, in which case it could start a
      // delimiter row.
      { atBreak: !0, character: ":", after: "-" },
      // A delimiter row can also start with a dash, when followed by more
      // dashes, a colon, or a pipe.
      // This is a stricter version than the built in check for lists, thematic
      // breaks, and setex heading underlines though:
      // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>
      { atBreak: !0, character: "-", after: "[:|-]" }
    ],
    handlers: {
      inlineCode: T,
      table: g,
      tableCell: u,
      tableRow: C
    }
  };
  function g(e, r, t, n) {
    return h(w(e, t, n), e.align);
  }
  function C(e, r, t, n) {
    const l = b(e, t, n), a = h([l]);
    return a.slice(0, a.indexOf(`
`));
  }
  function u(e, r, t, n) {
    const l = t.enter("tableCell"), a = t.enter("phrasing"), i = t.containerPhrasing(e, {
      ...n,
      before: s,
      after: s
    });
    return a(), l(), i;
  }
  function h(e, r) {
    return p(e, {
      align: r,
      // @ts-expect-error: `markdown-table` types should support `null`.
      alignDelimiters: d,
      // @ts-expect-error: `markdown-table` types should support `null`.
      padding: o,
      // @ts-expect-error: `markdown-table` types should support `null`.
      stringLength: f
    });
  }
  function w(e, r, t) {
    const n = e.children;
    let l = -1;
    const a = [], i = r.enter("table");
    for (; ++l < n.length; )
      a[l] = b(n[l], r, t);
    return i(), a;
  }
  function b(e, r, t) {
    const n = e.children;
    let l = -1;
    const a = [], i = r.enter("tableRow");
    for (; ++l < n.length; )
      a[l] = u(n[l], e, r, t);
    return i(), a;
  }
  function T(e, r, t) {
    let n = x.inlineCode(e, r, t);
    return t.stack.includes("tableCell") && (n = n.replace(/\|/g, "\\$&")), n;
  }
}
export {
  R as gfmTableToMarkdown
};
//# sourceMappingURL=index.js.map

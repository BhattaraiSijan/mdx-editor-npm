import { encodeCharacterReference as s } from "./encode-character-reference.js";
function m(g, n, d) {
  const f = n.indexStack, o = g.children || [], e = [];
  let c = -1, r = d.before, i;
  f.push(-1);
  let h = n.createTracker(d);
  for (; ++c < o.length; ) {
    const p = o[c];
    let a;
    if (f[f.length - 1] = c, c + 1 < o.length) {
      let t = n.handle.handlers[o[c + 1].type];
      t && t.peek && (t = t.peek), a = t ? t(o[c + 1], g, n, {
        before: "",
        after: "",
        ...h.current()
      }).charAt(0) : "";
    } else
      a = d.after;
    e.length > 0 && (r === "\r" || r === `
`) && p.type === "html" && (e[e.length - 1] = e[e.length - 1].replace(
      /(\r?\n|\r)$/,
      " "
    ), r = " ", h = n.createTracker(d), h.move(e.join("")));
    let l = n.handle(p, g, n, {
      ...h.current(),
      after: a,
      before: r
    });
    i && i === l.slice(0, 1) && (l = s(i.charCodeAt(0)) + l.slice(1));
    const u = n.attentionEncodeSurroundingInfo;
    n.attentionEncodeSurroundingInfo = void 0, i = void 0, u && (e.length > 0 && u.before && r === e[e.length - 1].slice(-1) && (e[e.length - 1] = e[e.length - 1].slice(0, -1) + s(r.charCodeAt(0))), u.after && (i = a)), h.move(l), e.push(l), r = l.slice(-1);
  }
  return f.pop(), e.join("");
}
export {
  m as containerPhrasing
};
//# sourceMappingURL=container-phrasing.js.map
